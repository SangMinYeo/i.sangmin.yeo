# 스쿨 2일차

## 컴퓨터 개론
1. 하바드 구조 : 속도가 빠르다

2. 폰노이만 구조

    - 단순화
    - 낮은가격
    - 프로그램 메모리와 데이터 메모리가 구분되지 않고 하나의 버스를 가지는 구조
    - 메모리 속박 문제 및 버스 병목 문제를 가짐
    - 메모리 속박 : cpu가 빨라서 메모리가 속도를 따라가지 못함

* 최신의 컴퓨터 아키텍처는 하버드 구조와 폰 노이만 구조가 결합된 모습
* CPU의 캐시 메모리 향상에 관여
    * cpu 내부 - 하버드
    * cpu 외부 - 폰노이만

## 데이터의 표현방식

* 1101 -> 1의 보수:0010 -> 2의보수:0011

* 다양한 수를 표현을 하기 위해서 1과0의 조합으로 표현할 수 있는 한계가 있어 미리
규칙을 정해서 표현. 이러한 표현 방식은 다양하다
ex) IEEE754

## 문자열표현
* ASCII코드는 8bit로 문자를 표현하기 위한 코드표-로마자로만 구성
* UTF-8 많이 쓰이며 현존하는 모든 문자열을 표현할 수 있다고 함
* EUC-KR, CP-949 가 한글을 표현하기 위해 만든 완성형 방식 - 단점은 등록되어 있지 않은 글자는 표현할 수 없다.
* 국가 전산망, 기업 중에서 EUC-KR을 아직도 쓰고 있다.
* 0과 1을 표현함에 있어서도 다양한 방법이 존재하기 때문에 부호화 복호화가 필요함

## 32bit운영체제 vs 64bit운영체제
* 32비트에서 메모리와 통신할때 주소체계상 한번에 움직일 수 있는 0과 1의 조합이 4기가를 넘을 수 없었다.
* 64비트 체계로 바뀌면서 같이 바뀌는 환경 : IPv4 / IPv6
* IPv4 : 32bit
* IPv6 : 64bit

## 컴퓨터의 연산
* CPU : 가산기(더하기)
* 반가산기 -> 모식도 찾아보기
* 논리연산
    - AND : 논리곱 “&”로 표기하며 모두 1일때만 1 나머진 0
    - OR : 논리합 “|”로 표기하며 둘중에 하나만1이어도 1
    - NOT : “~”로 표시하며 비트를 모두 반전
    - XOR : 배타적 논리곱 “^”로 표시하며 둘이 다르면 1 같으면 0
    - NOR : 논리합(OR)의 NOT버전
    - NAND

2의 보수는 NOT 연산 후에 1을 더해줌
ex) 0110 - 0001
0110의 보수 1110 여기에 1을 더한 1111을 더한다
0110 + 1111 =10101 여기서 4비트이므로 맨앞 1을 표현못하고 0101이라서 5
여기서 1을 표현 못한 걸 overflow라고 함

* 비트 논리연산 vs 부울논리연산
    * &하나는 비트논리연산, &&두개는 부울논리연산
    * ~ 비트 NOT연산 , !는 부울 NOT 연산
비트연산 많이 쓰이는 예
ex) OMR카드
실제 답이 00010일때 답과 제출한 답안지를 and연산하여 1이 나오면 답 0이 나오면 오답
즉, 비트 마스킹이라고 하는데 자리수를 뽑아내기 위해 쓰임
또, 여러자리의 비트를 보낼때 낭비되는 자릿수를 줄이기 위함
0001 바나나  	0000
0010 사과		0010 사과
0100 딸리		0100 딸기 ===> 낭비를 줄이기위해 OR연산하여 0110으로 표현
1000 복숭아	0000

### Day2 Homework
1. RAM은 어떤 단어들의 약자이며 왜 RAM이라고 부르게 되었을까?
2. 한글을 표현할 수 있는 문자 인코딩 방식에는 무엇이 있을까? 각각의 장단점도 조사해보세요.
